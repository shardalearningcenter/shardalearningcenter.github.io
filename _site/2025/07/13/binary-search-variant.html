<h1 id="1-standard-binary-search">1. Standard Binary Search</h1>
<p>Find an exact element in a sorted array.</p>

<h2 id="-adjustments">ğŸ”§ Adjustments</h2>
<p>If midVal &lt; target: low = mid + 1</p>

<p>If midVal &gt; target: high = mid - 1</p>

<h2 id="-use-when">âœ… Use When:</h2>
<p>You need to check if an element exists in a sorted array.</p>

<h2 id="-java-code">ğŸ§  Java Code</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int binarySearch(int[] arr, int target) {
    int low = 0, high = arr.length - 1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] &lt; target) low = mid + 1;
        else high = mid - 1;
    }
    return -1; // not found
}

</code></pre></div></div>
<h2 id="-2-lower-bound-first-element--target">ğŸ§­ 2. Lower Bound (First Element â‰¥ Target)</h2>
<h3 id="-adjustments-1">ğŸ”§ Adjustments</h3>
<p>If arr[mid] &lt; target: low = mid + 1</p>

<p>Else: high = mid - 1</p>

<h3 id="-use-when-1">âœ… Use When:</h3>
<p>You need the first element â‰¥ target (e.g., start of range).</p>

<h3 id="-java-code-1">ğŸ§  Java Code</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int lowerBound(int[] arr, int target) {
    int low = 0, high = arr.length - 1, ans = arr.length;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] &gt;= target) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}
</code></pre></div></div>

<h2 id="-3-upper-bound-first-element--target">â›³ 3. Upper Bound (First Element &gt; Target)</h2>

<h3 id="-adjustments-2">ğŸ”§ Adjustments</h3>
<p>If arr[mid] &lt;= target: low = mid + 1</p>

<p>Else: high = mid - 1</p>

<h3 id="-use-when-2">âœ… Use When:</h3>
<p>You want to find the first element greater than the target.</p>

<h3 id="-java-code-2">ğŸ§  Java Code</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int upperBound(int[] arr, int target) {
    int low = 0, high = arr.length - 1, ans = arr.length;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] &gt; target) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}
</code></pre></div></div>

<h2 id="-4-find-first-occurrence-of-duplicate-element">ğŸ” 4. Find First Occurrence of Duplicate Element</h2>
<h3 id="-adjustments-3">ğŸ”§ Adjustments</h3>
<p>If arr[mid] == target: update ans = mid and search left (high = mid - 1)</p>

<p>Else standard binary search logic.</p>

<h3 id="-use-when-3">âœ… Use When:</h3>
<p>Duplicates exist, and you want the first index of the target.</p>

<h3 id="-java-code-3">ğŸ§  Java Code</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int firstOccurrence(int[] arr, int target) {
    int low = 0, high = arr.length - 1, ans = -1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            ans = mid;
            high = mid - 1;
        } else if (arr[mid] &lt; target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return ans;
}
</code></pre></div></div>

<h2 id="-5-find-last-occurrence-of-duplicate-element">ğŸ§® 5. Find Last Occurrence of Duplicate Element</h2>
<h3 id="-adjustments-4">ğŸ”§ Adjustments</h3>
<p>If arr[mid] == target: update ans = mid and search right (low = mid + 1)</p>

<p>Else standard binary search logic.</p>

<h3 id="-use-when-4">âœ… Use When:</h3>
<p>Duplicates exist, and you want the last index of the target.</p>

<h3 id="-java-code-4">ğŸ§  Java Code</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int lastOccurrence(int[] arr, int target) {
    int low = 0, high = arr.length - 1, ans = -1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            ans = mid;
            low = mid + 1;
        } else if (arr[mid] &lt; target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
   
    return ans;
}
</code></pre></div></div>

<h2 id="-summary-table">ğŸ¯ Summary Table</h2>

<h1 id="binary-search-variants-cheat-sheet">Binary Search Variants Cheat Sheet</h1>

<p>This table summarizes the most common binary search patterns, what conditions to check, how to adjust the search space, and what each variant is used for.</p>

<table>
  <thead>
    <tr>
      <th>Variant</th>
      <th>Condition at <code class="language-plaintext highlighter-rouge">mid</code></th>
      <th>Adjust <code class="language-plaintext highlighter-rouge">low</code> or <code class="language-plaintext highlighter-rouge">high</code></th>
      <th>Goal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Exact Match</td>
      <td><code class="language-plaintext highlighter-rouge">arr[mid] == target</code></td>
      <td><code class="language-plaintext highlighter-rouge">low = mid + 1</code> or <code class="language-plaintext highlighter-rouge">high = mid - 1</code></td>
      <td>Find element index</td>
    </tr>
    <tr>
      <td>Lower Bound</td>
      <td><code class="language-plaintext highlighter-rouge">arr[mid] &gt;= target</code></td>
      <td><code class="language-plaintext highlighter-rouge">high = mid - 1</code></td>
      <td>First â‰¥ target</td>
    </tr>
    <tr>
      <td>Upper Bound</td>
      <td><code class="language-plaintext highlighter-rouge">arr[mid] &gt; target</code></td>
      <td><code class="language-plaintext highlighter-rouge">high = mid - 1</code></td>
      <td>First &gt; target</td>
    </tr>
    <tr>
      <td>First Occurrence</td>
      <td><code class="language-plaintext highlighter-rouge">arr[mid] == target</code></td>
      <td><code class="language-plaintext highlighter-rouge">high = mid - 1</code></td>
      <td>Leftmost match</td>
    </tr>
    <tr>
      <td>Last Occurrence</td>
      <td><code class="language-plaintext highlighter-rouge">arr[mid] == target</code></td>
      <td><code class="language-plaintext highlighter-rouge">low = mid + 1</code></td>
      <td>Rightmost match</td>
    </tr>
  </tbody>
</table>

<h2 id="notes">Notes</h2>

<ul>
  <li><strong>Lower Bound</strong>: Useful for finding where an element can be inserted without breaking the sort order.</li>
  <li><strong>Upper Bound</strong>: Helps in range queries, e.g., count of elements equal to a value.</li>
  <li>These patterns assume the array is <strong>sorted in ascending order</strong>.</li>
</ul>

<p>Let me know if you want binary search on rotated sorted arrays, peak elements, or 2D matrices next.</p>

<p>You said:
whats lower bound upper cound meaning</p>

<p>ChatGPT said:
Great question!</p>

<p>ğŸ“Œ Lower Bound and Upper Bound are binary search variants used to find the position (not necessarily the exact match) of elements in a sorted array.
ğŸ”½ Lower Bound
â“ What it means:
The index of the first element that is greater than or equal to the target.</p>

<p>âœ… Use when:
You want to find the starting point of a range, or check how many elements are less than the target.</p>

<p>ğŸ” Example:
java
Copy
Edit
int[] arr = {2, 4, 4, 4, 6, 8};
int target = 4;</p>

<p>// Lower bound of 4 is index 1 (first 4)
ğŸ”¼ Upper Bound
â“ What it means:
The index of the first element that is strictly greater than the target.</p>

<p>âœ… Use when:
You want to find the ending point of a range, or count how many elements are less than or equal to the target.</p>

<p>ğŸ” Example:
java
Copy
Edit
int[] arr = {2, 4, 4, 4, 6, 8};
int target = 4;</p>

<p>// Upper bound of 4 is index 4 (first element &gt; 4, which is 6)
ğŸ” Real-world Use Case:
Say youâ€™re counting how many times target = 4 appears:</p>

<p>java
Copy
Edit
count = upperBound(arr, 4) - lowerBound(arr, 4);
// = 4 - 1 = 3
ğŸ§  Visualization:
For arr = {2, 4, 4, 4, 6, 8} and target = 4:</p>

<p>makefile
Copy
Edit
Indexes:      0  1  2  3  4  5
Values:       2  4  4  4  6  8
                 â†‘     â†‘
              LB=1   UB=4</p>
